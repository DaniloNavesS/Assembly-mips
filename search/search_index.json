{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MIPS - ASSEMBLY","text":""},{"location":"#processo-de-compilacao","title":"Processo de compila\u00e7\u00e3o","text":""},{"location":"#risc-vs-cisc","title":"RISC vs CISC","text":""},{"location":"#representacoes-das-instrucoes","title":"Representa\u00e7\u00f5es das instru\u00e7\u00f5es","text":"<p>S\u00e3o separadoss em 3 formatos padr\u00f5es:</p> <p>Tipo R (3 Registradores)</p> op rs rt rd shant function 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits <p>op: c\u00f3digo da opera\u00e7\u00e3o</p> <p>funct: c\u00f3digo aritmetico</p> <p>rs e rt: registradores de opera\u00e7\u00e3o (em ordem)</p> <p>rd: operador de destino</p> <p>shant: tamanho do deslocamento</p> op rs rt rd shant function Tipo R $s1 $s2 $st0 0 add 0 17 18 8 0 32 <p>Tipo I (2 Regs e 1 const )</p> op rs rt constante / end 6 bits 5 bits 5 bits 16 bits <p>op: c\u00f3digo da opera\u00e7\u00e3o</p> <p>rs e rt: registradores de opera\u00e7\u00e3o (em ordem)</p> <p>OBS: No tipo I, a constante varia de -2^15 a 2^15-1</p> Tipo I $t0 $s0 21 4 8 16 21 <p>Tipo J ()</p> op end 6 bits 26 bits <p>\u00c9 o formato das instru\u00e7\u00f5es j, jal e jr</p>"},{"location":"arquitetura/","title":"MIPS - ASSEMBLY","text":""},{"location":"arquitetura/#processo-de-compilacao","title":"Processo de compila\u00e7\u00e3o","text":""},{"location":"arquitetura/#risc-vs-cisc","title":"RISC vs CISC","text":""},{"location":"arquitetura/#representacoes-das-instrucoes","title":"Representa\u00e7\u00f5es das instru\u00e7\u00f5es","text":"<p>S\u00e3o separadoss em 3 formatos padr\u00f5es:</p> <p>Tipo R (3 Registradores)</p> op rs rt rd shant function 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits <p>op: c\u00f3digo da opera\u00e7\u00e3o</p> <p>funct: c\u00f3digo aritmetico</p> <p>rs e rt: registradores de opera\u00e7\u00e3o (em ordem)</p> <p>rd: operador de destino</p> <p>shant: tamanho do deslocamento</p> op rs rt rd shant function Tipo R $s1 $s2 $st0 0 add 0 17 18 8 0 32 <p>Tipo I (2 Regs e 1 const )</p> op rs rt constante / end 6 bits 5 bits 5 bits 16 bits <p>op: c\u00f3digo da opera\u00e7\u00e3o</p> <p>rs e rt: registradores de opera\u00e7\u00e3o (em ordem)</p> <p>OBS: No tipo I, a constante varia de -2^15 a 2^15-1</p> Tipo I $t0 $s0 21 4 8 16 21"},{"location":"examples/","title":"Exemplos resolvidos em Assembly Mips","text":""},{"location":"examples/#exemplo-de-codigo","title":"Exemplo de c\u00f3digo","text":"<pre><code>.data\n    msg: .asciiz \"Hello word\\n\" # Criar um const com caracteres ascii\n\n.text\nmain:\n    li $v0, 4\n    la $a0, msg\n    syscall\n\n    li $v0, 10 # Encerra o codigo, parecido com return 0\n    syscall\n</code></pre>"},{"location":"examples/#ola-mundo","title":"Ol\u00e1 mundo","text":"<p>Printa ol\u00e1 mundo na saida.</p> <pre><code>.data\n    msg: .asciiz \"Ola mundo\\n\"      # Criar um const com valor \"Ola mundo\"\n\n.text\nmain:\n    li $v0, 4               # imprime uma label \n    la $a0, msg             # la = Load adress, carrega um adress da .data\n    syscall\n\n    li $v0, 10              # Encerra o codigo, parecido com return 0\n    syscall\n</code></pre>"},{"location":"examples/#soma-de-inteiros","title":"Soma de inteiros","text":"<pre><code>.data\n    br: .asciiz \"\\n\"        # Quebra de linha \n.text\n\nmain:\n    li $v0, 5               # L\u00ea uma linha de inteiros\n    syscall\n    move $t0, $v0           # Pega o valor digitado e adiciona no $t0\n\n    li $v0, 5               # L\u00ea uma linha de inteiros\n    syscall\n    move $t1, $v0           # Pega o valor digitado e adiciona no $t1\n\n    add $a0, $t0, $t1       # Efetua a operacao de soma\n\n    li $v0, 1               # imprime o valor de $a0, no caso, o resultado da soma\n    syscall\n\n    la $a0, br              # Carrega o \"/n\"\n    li $v0, 4               # Imprime a break line (br)\n    syscall\n\n    li $v0, 10              # Encerra o programa\n    syscall\n</code></pre>"},{"location":"instrucoes/","title":"Instru\u00e7\u00f5es - Assembly","text":""},{"location":"instrucoes/#estrutura-main","title":"Estrutura main","text":"<pre><code>    .data           # Se\u00e7\u00e3o de dados\n    .text           # Se\u00e7\u00e3o de c\u00f3digo\n    main:           # R\u00f3tulo\n    li $v0, 10 # Encerra o codigo, parecido com return 0\n    syscall\n</code></pre>"},{"location":"instrucoes/#tipo-de-dados","title":"Tipo de dados","text":"<p>.word w1,w2,...wm -&gt; dado de 32 bits;</p> <p>.byte b1,b2,...bm -&gt; dados de 8 bits;</p> <p>.asciiz str -&gt; cadeia de caracteres ASCII terminados pelo caracter nulo.</p> <p>Exemplo:</p> <pre><code>x: .word 120 #Se eu colocar \"x: .word 120,130,140\" seria como um vetor sequencial\n</code></pre>"},{"location":"instrucoes/#registradores","title":"Registradores","text":"# do Reg. Nome Descri\u00e7\u00e3o 0 $zero Retorna valor 0 2~3 $v0-$v1 (values) separado para setar valores de syscall 4~7 $a0-$a3 Registradores de Argumentos 8~15 $t0-$t7 Registradores Tempor\u00e1rios 16~23 $s0-$s7 Registradores de Perman\u00eancia 24~25 $t8-$s9 Registradores Tempor\u00e1rios"},{"location":"instrucoes/#operacoes","title":"Opera\u00e7\u00f5es","text":"<p>Opera\u00e7\u00f5es possui o formato:</p> <pre><code>*operador* $resultado, $valor1, $valor2\n</code></pre> <p>Operadores:</p> Opera\u00e7\u00e3o Estrutura A\u00e7\u00e3o Somar add $t0, $t1, $t2 Soma o valor de $t1 + $t2 e o resultado vai para o $t0"},{"location":"instrucoes/#funcoes","title":"Fun\u00e7\u00f5es","text":"Call Fun\u00e7\u00e3o Estrutura A\u00e7\u00e3o Mover move $t0, $v0 Transfere o valor de $t0 para $v0 Carregamento imediato li $v0, 5 Declara o valor de 5 para $v0 Carregamento de endere\u00e7o la $a0, msg Carrega o endere\u00e7o de msg e armazena em $a0"},{"location":"instrucoes/#deslocamento-de-memoria","title":"Deslocamento de mem\u00f3ria","text":"<p>1. Deslocamento de m\u00e9moria tipo R</p> <p>Esquerda</p> <pre><code>    sll $t0, $s0, 4\n</code></pre> <p>4 = quantidade de bits -&gt; shamt</p> <p>Direita</p> <pre><code>    srl $t0, $s0, 10\n</code></pre>"},{"location":"instrucoes/#operacoes-logicas","title":"Opera\u00e7\u00f5es l\u00f3gicas","text":"<p>and, or, xor, nor</p> <p>Geralmente usadas para:</p> <ol> <li>Condi\u00e7\u00f5es compostas </li> <li>M\u00e1scaras</li> </ol>"},{"location":"instrucoes/#mascaras","title":"M\u00e1scaras","text":"<p>M\u00e1scara s\u00e3o opera\u00e7\u00f5es para lidar com bits de uma palavra</p> <p>Ex: Extrair o bit menos significativo</p> <p>$t0 = 0010 0001 1100 0011</p> <p>$t9 = 0000 0000 0000 0001</p> <p>$t2 = 0000 0000 0000 0001</p> <p>Ex:. m\u00e1scara</p> <p>and $t2, $t0, $t9</p>"},{"location":"instrucoes/#instrucoes-condicionais","title":"Instru\u00e7\u00f5es condicionais","text":"instru\u00e7\u00e3o Estrutura Ex Fun\u00e7\u00e3o slt slt reg, r1, r2 Set on less than if ( r1 &lt; r2 ) reg = 1, else reg = 0 <p>OBS: sltu pode retornar valores diferentes de slt</p>"},{"location":"instrucoes/#instrucoes-de-desvio-condicional","title":"Instru\u00e7\u00f5es de desvio condicional","text":"instru\u00e7\u00e3o Estrutura Ex Fun\u00e7\u00e3o beq beq r1, r2, label Branch if EQual if ( r1 == r2 ) Desvia para label bne bne r1, r2, label Branch if Not Equal if ( r1 != r2 ) Desvia para label <p>EX::. 1. Desvio para label se r1 &gt;= r2?</p> <pre><code>slt $t0, r1, r2             # r1 &lt; r2\nbeq $t0, $zero, label       # Se $t0 = 0, ent\u00e3o r1 !&lt; r2 logo, r1 &gt;= r2\n</code></pre> <p>EX:. 2. Desviar para label r1 &gt; r2:</p> <pre><code>slt $t0, r2, r1\nbne $t0, $zero, label\n</code></pre> <p>Para os exemplos 1 e 2, h\u00e1 duas pseudo-instru\u00e7\u00f5es</p> instru\u00e7\u00e3o Estrutura Ex Fun\u00e7\u00e3o bge bge r1, r2, label Branch  on Greater than or Equal to if ( r1 &gt;= r2 ) Desvia para label bgt bgt r1, r2, label Branch on Greater Than if ( r1 &gt; r2 ) Desvia para label"},{"location":"instrucoes/#desvio-incondicional","title":"Desvio incondicional","text":"<pre><code>j label     # Jump = Desvia para a label  \n</code></pre> <ol> <li>Deslocamento relativo ao PC</li> </ol> <p>Label se transforma na qtde. de instru\u00e7\u00f5es a apartir da instru\u00e7\u00e3o sendo executada.</p> <p>O end. de destino do desvio = 4 * label + PC</p> <p>EX:. </p> <p>em C</p> <pre><code>if( i == j ) \n    f = g + h;\nelse \n    f = g - h;\n</code></pre> <p>Em assembly</p> <p>f = $s0, g = $s1, j = $s4</p> <pre><code>main:\n    beq $s3, $s4, if\n    sub $s0, $s1, $s2\n    j fim\n    if: add $s0, $s1, $s2\n</code></pre>"},{"location":"instrucoes/#lacos-de-repeticao","title":"La\u00e7os de repeti\u00e7\u00e3o","text":"<p>La\u00e7os s\u00e3o combina\u00e7\u00f5es de desvio de condicionais</p> <p>Ex:. </p> <p>Em C</p> <pre><code>i = 0;\nwhile ( i &lt; n )  {\n    A[i] = 0;\n    i++;\n}\n</code></pre> <p>Em assembly</p> <p>i = $t0, n = $s0, A = $s1 </p> <pre><code>add $t0, $zero, $zero       # i = 0;\n\nloop: slt $t2, $t0, $s0     # i &lt; n;\n      beq $t2, $zero,  exit\n      sll $t1, $t0, 2\n      add $t1, $t0, $t1\n      sw $zero, 0($t1)\n      addi $t0, $t0, 1\n      j loop\nexit:\n</code></pre>"},{"location":"instrucoes/#procedimentos","title":"Procedimentos","text":"<pre><code>int main () {\n    media( a , b );\n    return 0;\n}\n</code></pre> <p>fluxo de chamada a procedimentos</p> <ol> <li>Coloque os argumentos nos registradores</li> <li>Desvie a execu\u00e7\u00e3o p/ o procedimento</li> <li>Ajuste o armazenamento no procedimento</li> <li>Execute o procedimento</li> <li>Armazene o resultado nos registradores</li> <li>Ajuste o armazenamento</li> <li>Retorne ao chamado</li> </ol> <p>Padr\u00e3o de registradores em procedimentos</p> <p>$a0 a $a3: Passagens de argumentos. $v0 e $v1: Retorno de procedimentos.</p> <p>Ajuste de armazenamento: $s0 a $s7 devem ser preservados</p>"},{"location":"instrucoes/#acesso-a-pilha","title":"Acesso a pilha","text":"<ol> <li>Inserir</li> </ol> <p>EX: Salvar $s0 e $s1 na pilha</p> <pre><code>add $sp, $sp, -8        # Abrir espaco\n\nsw $s0, 0($sp)          # Salvar na pilha\n\nsw $s1, 4($sp)          # Salvar na pilha\n</code></pre> <ol> <li>Remover</li> </ol> <pre><code>lw $s0, 0($sp)          # Restaurar valores\n\nlw $s1, 4($sp)          # Restaurar valores\n\naddi $sp, $sp, 8        # Restaura espa\u00e7o da pilha\n</code></pre>"},{"location":"instrucoes/#instrucoes-para-chamada-de-procedimentos","title":"Instru\u00e7oes para chamada de procedimentos","text":"<ol> <li>Desvia para o procedimento</li> </ol> <pre><code>jal procedimento        # Jump and link\n</code></pre> <p>Salva o end da pr\u00f3xima instru\u00e7\u00e3o no reg $ra(returning adress) Faz O desvio para o r\u00f3tulo procedimento</p> <ol> <li>Retorna ao chamador</li> </ol> <pre><code>jr $ra                 # Jump to returning\n</code></pre> <p>EX de fun\u00e7\u00e3o:</p> <p>Em C:</p> <pre><code>int main () {\n    int a = 3;\n    int b = 2;\n    printf(\"%d\\n\", media(a,b));\n    return 0;\n}\n\nint media(int a, int b) {\n    return (a + b)/2;\n}\n</code></pre> <p>Em Assembly:</p> <pre><code>main: \n    li $s0, 3\n    li $s1, 2\n\n    move $a0, $s0\n    move $a1, $s1\n\n    jal media \n\n    move $a0, $v0\n    li $v0, 1\n    syscall\n\n    li $v0, 10\n    syscall\n\n\nmedia: \n    add $v0, $a0, $a1\n    srl $v0, $v0, 1\n    jr $ra\n</code></pre>"},{"location":"instrucoes/#manipulacao-de-caracter","title":"Manipula\u00e7\u00e3o de caracter","text":"<ol> <li>Tabela ASCII     printf(\"%d\\n\", '2' - '0');     'a' - 'A' = 32;</li> <li>Instru\u00e7\u00f5es de acesso a mem\u00f3ria     lb/lbu $t0, 0($s0)  # Load byte     sb $t0, 0($s0)      # Store byte</li> </ol>"},{"location":"syscall/","title":"SYSCALL","text":"<p>Chamadas do sistema (System Call)</p> <p>Os 4 tipos de solicita\u00e7\u00f5es s\u00e3o:</p> <pre><code>1 - Escrita de sa\u00edda padr\u00e3o\n\n2 - Leitura da entrada padr\u00e3o\n\n3 - Aloca\u00e7\u00e3o de mem\u00f3ria\n\n4 - Encerramento de processo\n</code></pre>"},{"location":"syscall/#tabela-syscall","title":"Tabela Syscall","text":"A\u00e7\u00e3o Codigo em $v0 Argumento Resultado Printar Inteiro 1 $a0 Printar Float 2 $f12 Printar Double 3 $f12 Printar String 4 $a0 Leitura Inteiro 5 $a0 Inteiro em $v0 Leitura Float 6 $a0 float em $f0 Leitura Float 7 $a0 float em $f0 Leitura String 8 $a0 = Adress of input buffer, $a1 = Maximum number of characters to read Tabela externa Sbrk(Aloca\u00e7\u00e3o de memoria na HEAP) 9 $a0 = N\u00famero de bytes alocados $v0 cont\u00e9m o end de mem\u00f3ria alocada Exit (Encerrar processo) 10"}]}